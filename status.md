Оболочка
========

Маппинг пинов
-------------

0-7: PORTA
8-18: PORTB
19-21: PORTC
22-29: PORTD
30-35: PORTE
36-43: PORTF

Саммари функций
---------------

	public:
		void init(void);
		void cycle(void);
		void pinInit(int, int);
		void pinWrite(int, int);
		int pinRead(int);
		void portInit(MDR_PORT_TypeDef *, uint32_t);
		void portWrite(MDR_PORT_TypeDef *, uint32_t);
		uint32_t portRead(MDR_PORT_TypeDef *);
		void delay(void); //(fake)
		void snake(void); //(for test)

	private:
		void ports_clock_enable(void);
		void mila_init(void);
		int bit_from_virtual_pin(int);
		MDR_PORT_TypeDef *port_from_pin(uint16_t pin);
		MDR_PORT_TypeDef *port_from_virtual_pin(int);
		void Timer1_Init(void);
		void Timer2_Init(void);
		void Timer1_IRQHandler(void);
		void Timer2_IRQHandler(void);

void init(void);
----------------

Определение: test.c

Назначение: в этой функции пользователь размещает код инициализации

Использование: ---

Статус: полностью реализована

Под капотом: пишет пользователь

Проблемы: нет

void cycle(void);
-----------------

Определение: test.c

Назначение: в этой функции пользователь размещает код для циклического исполнения

Использование: ---

Статус: полностью реализована

Под капотом: пишет пользователь

Проблемы: нет

void pinInit(int, int);
-----------------------

Определение: gpio.c

Назначение: Инициализация отдельного пина GPIO на вход или на выход

Использование: pinInit(пин, режим)

 + *номер пина* - может использовать сквозную нумерацию 0-43 (см. "Маппинг пинов")  
 или номенклатуру "буква порта - цифра бита" типа A0, A1, B5, C3...
 + *режим* - IN или OUT

Статус: реализована с багами

Под капотом:  
В зависимости от способа представления номера пина выбирается способ определения порта и бита.  
 В `gpio.h` лежит пачка дефайнов с паттерном `0x0P0B`, где P - порт, B - бит. Наличие P -  
 признак того, что номер пина задан в номенклатуре "буква порта - цифра бита". Этот признак  
 проверяется маской 0xFF00. 

  + Если это "буква порта - цифра бита", то порт определяется функцией `port_from_pin(0xFF00&pin)`,  
 которая возвращает указатель на базовый адрес порта. Бит элементарно определяется маской `0x00FF & pin`.  
  + Если это сквозная нумерация, то порт и бит возвращаются функциями `port_from_virtual_pin(pin)`  
  и `bit_from_virtual_pin(pin)`, которые состоят из 6-ти if-ов.

Проблемы:  Если сначала объявить часть пинов одного порта выходами, а потом другую часть входами,  
то порт инициализируется некорректно, работать с ним невозможно. Если сделать наоборот, то всё норм.  
Что-то в pinInit(pin, IN) сбрасывает настройки pinInit(pin, OUT).


